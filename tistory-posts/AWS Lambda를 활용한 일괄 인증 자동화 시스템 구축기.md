<h2>매 학기 교사 인증이 필요해요</h2>
<p>처음 Edukit을 기획했을 때 교사분들을 인터뷰하며 가장 많이 들었던 요구는 &ldquo;교사 인증이 철저했으면 좋겠다&rdquo;는 것이었다. 신뢰할 수 있는 교육 플랫폼을 만들기 위해서는 교사 신분을 확실히 확인하는 절차가 필요했고, 이를 최대한 간편하면서도 정확하게 구현할 방법을 고민했다. 여러 방안을 검토한 끝에, 교육청에서 현직 교사에게만 발급하는 교육청 교사 이메일 도메인을 활용해 인증 메일을 발송하는 방식으로 결정했다. 이렇게 하면 복잡한 서류 절차 없이도 해당 도메인을 통해 교사 신분을 간접적으로 보증할 수 있다는 장점이 있었다.</p>
<p>하지만 여기서 한 가지 추가 요구가 있었다. 현재 활동 중인 교사만 인증 대상이 되길 원한다는 것이었다. 이미 가입 시점에서 인증을 받은 회원이라도 실제로는 퇴직했거나 다른 직종으로 전환했을 수 있기 때문에, 정기적인 재인증 절차가 필요하다는 의견이었다. 당시 Edukit에는 회원가입 시 1회만 인증을 진행하는 구조였고, 이미 인증된 계정에 대해 주기적으로 권한을 갱신하는 기능은 없었다. 결국 매 학기, 즉 1년에 두 번 모든 인증된 교사 계정을 대상으로 재인증을 수행하는 자동화 시스템을 구축하기로 했다.</p>
<p>이 작업은 주기가 1년에 두 번뿐이었기 때문에 상시 실행되는 EC2 인스턴스를 두는 것보다, 사용한 만큼만 비용이 발생하는 AWS Lambda를 사용하는 것이 더 효율적이라고 판단했다. Lambda를 사용하면 서버를 직접 관리할 필요가 없고, 필요할 때만 코드를 실행해 비용을 절감할 수 있기 때문이다. 이런 이유로 Lambda를 활용해 교사 인증 자동화 시스템을 설계하고 배포하기로 결심하였으며, 그 과정에서 여러 시행착오를 겪었다. 이번 글에서는 이러한 의사결정의 배경을 소개하고, 다음 글에서 Lambda를 기반으로 한 구현 과정과 트러블슈팅 사례를 다루고자 한다.</p>
<p>&nbsp;</p>
<h2>구현 과정</h2>
<h3>Batch 모듈을 배포하자</h3>
<p>초기에 멀티모듈 구조를 도입한 후, 교사 인증 배치 처리는 Batch 모듈에서 처리하기로 했다. 기존 기획에서는 교사 배치 처리 시 교사 상태 변경뿐만 아니라 교사 인증 메일 발송까지 한 번에 수행하기로 했기 때문이다. 이 과정에서 Core 모듈과 External 모듈의 로직을 많이 재사용하게 될 것으로 예상되었기 때문에, Batch 모듈을 따로 분리하여 이를 AWS Lambda로 배포하기로 결정했었다.</p>
<h4>Jar 파일 크기를 어떻게 줄일까?</h4>
<p>일단, 기존의 Core 모듈에는 Service 클래스들 뿐만 아니라 Facade 로직도 함께 존재했다. Facade 패턴을 도입한 이유는 각 서비스들간의 결합도를 줄이고 비즈니스 로직과 유즈케이스를 분리하고자 했기 때문이다. 팀원과의 의논 끝에, 유즈케이스는 Core 모듈에 있는 것이 아니라 Api 모듈에 두어 유즈케이스와 비즈니스 로직을 분리하는 것이 합당하는 결론에 이르렀고, Facade 계층을 모두 API 모듈로 이동시켰다. 이로써 Core 모듈에 존재하던 파일의 개수가 줄어들었다. 하지만 파일의 개수가 Jar의 용량에 크게 영향을 미치는 요소는 아니었기에 가장 큰 영향을 미치는 의존성을 제거할 필요가 존재했다.</p>
<p>그런데!!&nbsp; 문제가 발생했다. AWS Lambda에는 배포 패키지 용량 제한(압축 후 50MB, 압축 해제 후 약 250MB)이 있는데, Batch 모듈에서 생성된 Fat JAR 파일 크기가 무려 87MB였던 것이다. Batch 모듈은 사실 AWS SES 의존성과 Slack Webhook 의존성, 그리고 멤버 상태 업데이트를 위한 최소한의 의존성만 필요하다. 하지만 Core 모듈에는 엔티티 정의뿐 아니라 다양한 비즈니스 로직까지 포함되어 있어, 불필요한 의존성과 파일들이 함께 빌드되어 JAR 크기가 불필요하게 커진 상태였다.</p>
<p><figure class="imageblock alignCenter"><span><img height="317" src="https://blog.kakaocdn.net/dn/c0j73x/btsPO9L4nbB/DGhfd6DHqGScPkcJLOTkMK/img.jpg" width="238" /></span><figcaption>수 없이 실패한 흔적들..</figcaption>
</figure>
</p>
<p>우선, Core 모듈에는 Service 클래스뿐 아니라 Facade 계층도 함께 존재했다. Facade 패턴을 도입한 이유는 서비스 간 결합도를 줄이고 비즈니스 로직과 유즈케이스를 분리하기 위함이었다. 팀원과 논의 끝에, 유즈케이스는 Core 모듈이 아니라 API 모듈에 두는 것이 더 적절하다는 결론에 도달했고, Facade 계층을 전부 API 모듈로 이동시켰다.</p>
<blockquote>API 모듈은 외부에서 들어오는 요청을 받고, 이를 처리하는 애플리케이션 계층의 책임을 진다. 유즈케이스(Use Case)는 도메인 로직을 조합하여 특정 시나리오를 수행하는 작업 흐름이기 때문에, API 요청&middot;응답과 밀접하게 연결된다고 생각했다.</blockquote>
<p>이로써 Core 모듈 내 파일 수는 줄었지만, 파일 수 자체는 JAR 용량에 큰 영향을 주지 않으므로, 가장 큰 영향을 미치는 의존성 자체를 줄이는 작업이 핵심적으로 필요했다.</p>
<p><figure class="imageblock widthContent"><span><img height="896" src="https://blog.kakaocdn.net/dn/zxffa/btsPNgLWT9v/l7XXCM0hRyR5d0bKRBfzO0/img.png" width="1628" /></span></figure>
</p>
<p>&nbsp;</p>
<p>우리의 설계에서는 Core 모듈이 External 모듈을 직접 참조하고 있었다. 즉, External 모듈의 서비스 구현체를 Core 모듈이 직접 의존하고 있었기 때문에 강결합이 발생했고, 이로 인해 External 모듈의 전체 의존성이 Core 모듈로 전이되어 컴파일 타임에도 불필요하게 의존하게 된 것이다. 이를 해결하기 위해 의존성 방향을 역전시켰다. Core 모듈에 필요한 기능을 정의하는 인터페이스를 두고, External 모듈이 이 인터페이스를 구현하도록 변경했다. 그 결과, Batch나 API 모듈에서는 External 모듈을 런타임 시에만 의존하도록 할 수 있었고, Core 모듈의 빌드 시 External 모듈의 불필요한 의존성이 포함되지 않게 되었다. 추가로 Gradle의 exclude 옵션을 사용하여 필요 없는 라이브러리를 컴파일 타임에서 제외했다. 그 결과, Batch 모듈의 JAR 파일 크기를 87MB &rarr; 63MB로 줄일 수 있었다.</p>
<p>하지만 여전히 JAR 용량은 기준 제한인 50MB를 초과하고 있었다. 현재의 모듈 구조에서는 이 이상 JAR 용량을 줄이기는 어렵다고 판단했고, <b>Lambda를 계속 사용하면서도 용량 제한을 피할 수 있는 방법</b>을 고민하게 되었다.</p>
<h4>Container Lambda</h4>
<p>그 과정에서 Container Lambda라는 방식을 알게 되었다. Container Lambda는 AWS Lambda 함수 코드를 ZIP 파일 대신 Docker 컨테이너 이미지로 배포하는 방법이다. 일반 Lambda는 ZIP 형태의 코드를 직접 업로드하지만, Container Lambda는 Docker 이미지를 Amazon ECR에 저장하고 이를 실행하는 방식으로 동작한다. 다만, Container Lambda는 ECR과만 연동 가능하다는 제약이 있다. 다행히도 우리 팀은 이미 API 모듈의 CI/CD 과정에서 ECR을 사용하고 있었기 때문에, 이 제약은 문제가 되지 않았다. Container Lambda는 최대 10GB 용량까지 지원하므로, 복잡하고 큰 의존성을 가진 애플리케이션도 무리 없이 배포할 수 있다. 또한 Lambda 업데이트 시 ECR 이미지 버전만 교체하면 되기 때문에, 배포 과정도 단순하다. 하지만 단점도 있다. 이미지 빌드와 업로드 과정 때문에 배포 속도가 느리고, ECR 저장 비용이 발생한다. 특히 이미지가 클수록 콜드 스타트 지연이 심해질 수 있다.</p>
<p>분명 Container Lambda는 용량 문제를 단번에 해결할 수 있는 방법이었다. 그러나 이번 교사 인증 배치는 메일 전송과 상태 변경 정도의 단순 작업이었고, 배포 과정과 인프라 복잡도를 불필요하게 높이는 것은 유지보수 효율 측면에서 비합리적이라고 판단했다. 이에 따라, 보다 단순하면서도 Lambda 용량 제한을 회피할 수 있는 다른 대안을 찾기로 했다.</p>
<h4>Lambda Layer</h4>
<p>그렇게 더 단순하고 효율적인 방법을 찾던 중, AWS Lambda Layer를 활용하는 방안을 검토하게 되었다. Lambda Layer는 쉽게 말해 공통 라이브러리를 Lambda 함수 코드와 분리해 배포할 수 있는 기능이다. Layer에 올려둔 라이브러리는 여러 Lambda 함수에서 재사용할 수 있으며, 함수 코드 패키지 크기에 포함되지 않기 때문에 ZIP 용량 제한(50MB)을 우회할 수 있다. 예를 들어, 이번 Batch 모듈에서 사용하는 AWS SDK, Slack Webhook 클라이언트, 이메일 전송 관련 라이브러리 등을 Layer로 분리하면, 함수 코드에는 오직 비즈니스 로직만 남기고 필요한 라이브러리를 실행 시점에 참조할 수 있다.</p>
<p>우리 서비스의 교사 인증 배치의 경우, 필요한 라이브러리들이 한 번 설치하면 자주 변경되지 않고, 여러 Lambda 함수에서도 재사용 가능하다는 점에서 Layer 활용이 적합하다고 판단했다. 따라서 Core 모듈의 비즈니스 로직을 최소화된 형태로 패키징하고, 외부 SDK와 클라이언트 라이브러리는 Layer로 분리하여 배포하는 전략을 세웠다.</p>
<h3>Lambda Layer 도입</h3>
<p><figure class="imageblock widthContent"><span><img height="914" src="https://blog.kakaocdn.net/dn/enQC8S/btsPO3SCZdV/BLbo9QxkxpJJO3jKAJVgcK/img.png" width="1556" /></span><figcaption>전체적인 흐름도</figcaption>
</figure>
</p>
<h4>Layer를 어떻게 분리할 것인가?</h4>
<p>초반에는 단순하게 기능별로 의존성을 분리하여 Layer를 분리하면 될 것이라고 생각하였다. 영속성 계층에 관한 의존성(DB, JPA 등등), Spring에 대한 의존성, 외부 서비스에 대한 의존성 이런식으로 기능별로 의존성들을 분리해 각각 Layer에 배포해두고 비즈니스 로직이 존재하는 애플리케이션 코드만 Lamda 함수로 배포하여 필요한 Layer를 참조하는 구조로 설계를 했었다.</p>
<p><figure class="imageblock widthContent"><span><img height="536" src="https://blog.kakaocdn.net/dn/cBzlvE/btsPNKF2iDc/P221dRDyj9950T8QBEfK8k/img.png" width="1566" /></span></figure>
</p>
<p>&nbsp;</p>
<p>하지만, 실제 배포 과정에서 문제가 생겼다. Layer에만 포함된 필수 의존성(JPA, DB 드라이버 등)이 함수 코드 패키지에는 없으니, Lambda 실행 시점에서 NoClassDefFoundError와 같은 런타임 오류가 발생한 것이다. 즉, 실행 시 반드시 필요한 라이브러리를 기능 단위로 쪼개면서, 서로 의존하는 라이브러리 집합이 분리돼버린 것이 문제였다.</p>
<p>이 문제를 해결하기 위해 기능 단위가 아닌 모듈 단위로 Layer를 구성하는 방식으로 전환했다. Core 모듈 Layer, External 모듈 Layer, Infra 모듈 Layer처럼 이미 Gradle 모듈 단위로 의존성이 정리된 구조를 그대로 Layer로 옮기는 것이다. 이렇게 하면 각 Layer가 해당 모듈의 모든 필수 라이브러리를 포함하게 되어, 빌드와 실행 시점 모두에서 누락 오류를 방지할 수 있었다.</p>
<p><figure class="imageblock widthContent"><span><img height="391" src="https://blog.kakaocdn.net/dn/caJLk2/btsPLgsYa3S/8KUTutkoBI65h9KEs2lHLk/img.png" width="1979" /></span></figure>
</p>
<h3>이게 최선일까?</h3>
<p>사실 Lambda Layer를 이용해 배포에는 성공했지만, 기획적인 측면과 코드 구조 측면에서 고민이 많았다. Layer 방식을 적용한 뒤 Batch 모듈의 build.gradle 파일은 각 의존성을 Layer 단위로 분리하기 위해 무려 294줄로 늘어났고, Layer를 빌드&middot;배포하기 위한 별도의 쉘 스크립트와 최종적으로 이를 실행하기 위한 CI/CD 워크플로우 파일까지 필요하게 되었다. 결과적으로 단순한 배치 작업에 과도한 리소스가 투입되는 구조가 되었고, 무엇보다도 내가 작성한 워크플로우 로직을 스스로도 완벽히 이해하지 못한 상태였기 때문에 장기적으로는 유지보수 리스크가 커질 수밖에 없다고 판단했다.</p>
<p>기획적인 측면에서도 근본적인 의문이 들었다. 교사의 인증 상태를 초기화한 직후 인증 메일을 발송하는 플로우가 과연 맞는가? 우리의 배치 작업은 사용자가 거의 활동하지 않는 자정에 실행되는데, 인증 메일의 유효 기간은 5분 뿐이었다. 즉, 다음 날 아침에 사용자가 메일을 확인하더라도 인증 코드는 이미 만료되어 있었고, 결국 사용자가 다시 &lsquo;인증 메일 재전송&rsquo;을 눌러야 하는 불필요한 절차가 발생하고 있었다. 여러 차례 고민 끝에, 교사 인증 상태만 초기화하고 메일 전송은 배치에서 제외하기로 결정했다. 이렇게 되면 Batch 모듈에서 External 모듈에 대한 의존성이 전혀 필요 없어지게 된다. 더하여 &ldquo;단순히 교사 상태만 업데이트하는 배치 작업을 굳이 별도의 모듈로 분리할 필요가 있을까?&rdquo;, &ldquo;더 나아가, 이런 단순 작업을 꼭 Spring Boot 같은 무거운 프레임워크에서 실행해야 할까?&rdquo;라는 의문이 들었다. 결국, 콜드 스타트 부담이 적은 <b>Node.js 기반 Lambda 함수</b>로 단순 로직을 구현하는 편이, 유지보수성과 성능 면에서 훨씬 합리적이라는 결론에 이르게 되었다.</p>
<h4>Batch 모듈을 삭제하다.</h4>
<p>이틀을 불태워 작업했던 Batch 모듈을 결국 삭제하기로 결심했다.</p>
<p><figure class="imageblock widthContent"><span><img height="676" src="https://blog.kakaocdn.net/dn/AUTMF/btsPM19oKm3/SHyH1BZ4YcCbiI1Dl5xI90/img.png" width="1186" /></span></figure>
</p>
<p>최종적으로 완성된 배치 플로우는 다음과 같다. AWS EventBridge를 활용하여 매년 3월 1일과 9월 1일에 Lambda 함수가 자동으로 실행되도록 트리거를 설정하였다. 만약 Lambda 함수 호출이 실패할 경우, DLQ(Dead Letter Queue)와 슬랙 알림을 통해 재처리 절차가 진행되도록 하여 배치 작업의 안정성을 확보하였다. 또한, 코드 패키지 크기는 총 599.8KB로 크게 경량화되어, 이전보다 훨씬 빠르고 효율적으로 작업을 수행할 수 있게 되었다.</p>