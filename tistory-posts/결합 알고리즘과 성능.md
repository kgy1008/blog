<h2>결합 알고리즘</h2>
<p>옵티마이저가 선택 가능한 결합 알고리즘은 크게 3가지가 존재한다. 어떤 알고리즘을 선택할 지 여부는 데이터 크기 또는 결합 키의 분산이라는 요인에 의존하는데, 그 중 가장 빈번하게 볼 수 있는 알고리즘은 Nested Loops로 결합 알고리즘의 기본이 되는 알고리즘이다. MySQL의 옵티마이저도 기본적으로 Nested Loop Join을 사용하여 테이블을 조인한다고 한다.</p>
<h3>Nested Loops</h3>
<p>Nested Loops는 이름 그대로 중첩 반복을 사용하는 알고리즘이다.&nbsp;</p>
<p><figure class="imageblock alignCenter"><span><img height="352" src="https://blog.kakaocdn.net/dn/GwS8G/btsNeo7Bap8/W09fBKE840BwZcdkZ2MiHK/img.png" width="764" /></span></figure>
</p>
<ol>
<li><b>결합 대상 테이블(Table A)에서 레코드를 하나씩 반복하며 스캔한다.</b> <br />이런 테이블을 드라이빙 테이블(Driving Table) 또는 외부 테이블(Outer Table)이라고 한다. 다른 테이블(Table B)는 드리븐 테이블(Driven Table) 또는 내부 테이블(Inner Table)이라고도 부른다.</li>
<li><b>드라이빙 테이블의 레코드 하나마다 드리븐 테이블의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴한다.</b></li>
<li><b>이런 작동을 드라이빙 테이블의 모든 레코드에 대해 반복한다.</b><b></b></li>
</ol>
<p>이처럼 Nested Loops의 구체적인 동작 방식은 본질적으로 이중 반복문과 비슷하다. Nested Loops의 동작 방식을 살펴보면 드라이빙 테이블에서 한 행씩 읽고, 그때마다 드리븐 테이블에서 매칭 행 찾는 방식으로 동작한다. 이는 다른 결합 알고리즘과 비교했을 때, 한 번의 단계에서 처리하는 레코드 수가 적으므로 Hash 또는 Sort Merge에 비해 메모리 소비가 적다는 특징이 있다. 또한&nbsp;<span style="color: #333333; text-align: start;">이중 반복문의 시간 복잡도가 O(N^2)인 것 처럼 Nested Loops의 실행 시간 역시 R(A) * R(B)가 된다.<span>&nbsp;</span></span></p>
<h4>성능적 관점</h4>
<p>얼핏 보기에 Nested Loops에서는 드라이빙 테이블이 무엇이든 간에 접근하는 레코드 수가 항상 R(A) * R(B)일 것처럼 보인다. 하지만 이는 드리븐 테이블에 인덱스가 없을 경우에만 해당되는 이야기다.<br /><b>인덱스가 존재하는 경우, 어떤 테이블을 드라이빙 테이블로 선택하느냐에 따라 성능에 큰 영향을 미친다.</b> 때문에 일반적으로는 <b>작은 테이블을 드라이빙 테이블로 선택</b>하라는 조언이 많이 등장한다. 다만 이 조언에는 드리븐 테이블의 조인 키에 인덱스가 존재해야 한다는 암묵적인 전제가 포함되어 있음을 꼭 기억하자! 인덱스가 없을 경우에는 아무리 드라이빙 테이블이 작아도 성능 개선 효과는 크지 않다.</p>
<p><figure class="imageblock alignCenter"><span><img height="335" src="https://blog.kakaocdn.net/dn/ctDNWI/btsNdQQZVeQ/dFGEekiJkKToUEAc2IMyX0/img.png" width="798" /></span><figcaption>결합 인덱스 존재</figcaption>
</figure>
</p>
<p>내부 테이블의 결합 키 필드에 인덱스가 존재한다면, DBMS는 드리븐 테이블을 매번 풀스캔하지 않고, 해당 키 값을 기준으로 빠르게 원하는 레코드만 검색할 수 있다.</p>
<p>가장 이상적인 경우는, 드라이빙 테이블의 한 레코드에 대해 드리븐 테이블에서 정확히 한 레코드가 대응되는 상황으로(등치 결합), 드리븐 테이블의 인덱스를 활용하여 해당 레코드를 즉시 찾을 수 있어 반복 자체를 생략할 수 있다. 반복 자체를 생략할 수 있기 때문에 전체 접근 레코드 수는 R(A) * 2 수준까지도 줄일 수 있다.&nbsp;</p>
<p>&nbsp;</p>
<p>반면, 결합 키가 드리븐 테이블에 대해 유일하지 않는 경우는 인덱스로 드리븐 테이블에 접근하는 경우라도 여러 개의 레코드가 히트될 가능성이 있다. 이 경우에는 내부 반복을 완전하게 생략하는 것은 불가능하다. 따라서 이런 경우의 레코드 접근 횟수는 R(A) + &sum;(A_i에 매칭되는 B 레코드 수)이다. 해당 상황에도 레코드 개수가 많은 테이블을 드리븐 테이블로 설정하는 것이 성능상 좋다. 드리븐 테이블이 클수록 인덱스 사용으로 인한 반복 생략 효과를 더 크게 볼 수 있기 때문이다.</p>
<h4>Nested Loops의 단점</h4>
<p>Nested Loop Join 방식은 결합 키로 드리븐 테이블에 접근할 때, 히트되는 레코드가 너무 많다면 응답 시간의 지연이 발생할 수도 있다.</p>
<p><figure class="imageblock alignCenter"><span><img height="349" src="https://blog.kakaocdn.net/dn/CVaZ2/btsNfifhb8i/e7DHg4hkNI54meuVB3sS7K/img.png" width="756" /></span></figure>
</p>
<p>SQL의 성능은 궁극적으로 처리해야 하는 데이터의 양에 크게 좌우된다. 인덱스를 활용해 반복 접근을 줄일 수는 있지만, 전체적으로 처리해야 하는 양이 많다면 결국 반복이 많이 발생하고, 이는 응답 시간 지연으로 이어질 수 있다.</p>
<p>&nbsp;</p>
<p>이 문제에 대처하는 대표적인 방법은 다음과 같다.</p>
<ol>
<li><b>드리븐 테이블에 대한 반복 접근(히트)이 과도할 경우, 큰 테이블을 드라이빙 테이블로 선택하는 전략도 고려</b><br />예외적으로, 드리븐 테이블에 인덱스 기반 접근이 반복되면서 I/O 부하가 지나치게 커지는 경우, 차라리 <b>큰 테이블을 드라이빙 테이블로 선택</b>하고, 드리븐 테이블을 <b>기본 키 또는 인덱스로 단건 조회</b>하는 방식이 더 효율적일 수 있다.<br />이 경우, 드라이빙 테이블이 크더라도 WHERE 절 등으로 적절히 필터링되어 접근 비용이 현실적인 범위라면, 극단적인 성능 저하를 방지할 수 있다.</li>
<li><b>해시 알고리즘을 사용하는 조인 방식 활용</b><br />해시 조인은 일반적으로 정렬이나 인덱스를 활용하기 어려운 경우 좋은 대안이 될 수 있다. Hash 알고리즘에 대한 자세한 설명은 아래에 이어서 기술하고자 한다.</li>
</ol>
<h3>Hash</h3>
<p><figure class="imageblock alignCenter"><span><img height="525" src="https://blog.kakaocdn.net/dn/yZWDj/btsNKzgdsQd/uklwVEEvOC2DQhkY814ma1/img.png" width="711" /></span></figure>
</p>
<p>해시 결합(Hash Join)은 조인을 수행할 때 먼저 작은 테이블을 스캔하고,<span>&nbsp;</span>조인 키에 해시 함수를 적용하여 해시 테이블을 생성한다. 이후 다른 테이블(보통 더 큰 테이블)을 스캔하면서, 각 행의 조인 키를 해시 함수로 변환한 뒤, 해시 테이블에 일치하는 키가 존재하는지 확인하여 조인을 수행한다.</p>
<p style="color: #333333; text-align: start;">일반적으로 작은 테이블을 기준으로 해시 테이블을 생성하는 이유는, 해시 테이블이 DBMS의 워킹 메모리(버퍼 메모리)에 저장되기 때문에 더 작은 테이블을 선택하는 것이 메모리 사용 측면에서 더 효율적이기 때문이다.</p>
<h4>Hash의 특징</h4>
<p>Hash Join은 중간에 해시 테이블을 만들고 탐색하는 과정이 있어, 단순한 Nested Loops Join보다 메모리를 더 많이 사용할 수 있다. 특히 큰 테이블을 메모리에 모두 올릴 수 없는 경우, 디스크를 활용한 외부 해시 조인(Grace Hash Join)이 발생하며, 이로 인해 디스크 I/O가 증가하고 성능이 저하될 수 있다. 이러한 이유로 OLTP(Online Transaction Processing)처럼 <b>짧고 가벼운 쿼리가 반복적으로 실행되는 환경에서는</b>, Hash Join이 <b>메모리를 과도하게 점유하거나 I/O 병목을 초래할 수 있어 주의가 필요</b>하다. 하지만 모든 경우에 Hash Join이 부적합한 것은 아니며, <b>소규모 테이블 간 조인에서는 효율적으로 사용될 수도 있다.</b></p>
<p>Hash Join은 해시 함수를 기반으로 조인 조건을 처리하기 때문에, <b>동치 조인(Equi Join)에서만 사용</b>할 수 있다. 범위 조인(&gt;, &lt; 등)에는 부적합하다. 또한, Hash Join은 해시 테이블을 구성하기 위해 전체 테이블을 한 번씩은 반드시 읽어야 하므로, 인덱스를 활용하지 못하면 테이블 풀 스캔이 발생하는 경우가 많다. 따라서 테이블 크기가 매우 클 경우, 풀 스캔에 소요되는 시간과 자원도 고려해야 한다.</p>
<h4>Hash Join이 Nested Loop Join보다 유리한 상황</h4>
<p>우선, <b>두 테이블이 모두 크기가 크고 인덱스가 없는 경우</b> Hash Join이 특히 유리하다. Nested Loop Join은 외부 테이블의 각 행마다 내부 테이블을 반복 탐색하기 때문에, 내부 테이블에 인덱스가 없다면 매번 전체를 스캔해야 하며, 결과적으로 매우 높은 I/O 비용이 발생하게 된다. 반면, Hash Join은 두 테이블을 각각 한 번만 스캔하면서 조인을 수행하므로, 반복 횟수가 적고 더 일정한 성능을 낼 수 있다.</p>
<p>또한 <b>조인 조건이 동치(=)일 때</b> Hash Join은 최적화된 성능을 낼 수 있다. 해시 함수의 특성상 등호 조건을 기반으로 매칭을 빠르게 수행할 수 있기 때문이다. 반면, Nested Loop은 조건의 종류에 관계없이 단순 반복 비교 방식으로 수행되어 상대적으로 느릴 수 있다.</p>
<p><b>OLAP 환경처럼 대용량 데이터를 일괄로 처리하는 경우</b>에도 Hash Join이 적합할 수 있다. 분석 쿼리나 리포트용 조인처럼 많은 데이터를 한 번에 처리할 때, Hash Join은 해시 테이블을 생성하고 탐색하는 과정 모두에서 병렬 처리를 할 수 있기 때문이다.</p>
<p>마지막으로, <b>메모리가 충분한 경우</b> Hash Join은 더욱 강력한 성능을 낼 수 있다. 해시 테이블을 메모리에 유지하면서 빠르게 매칭을 수행하기 때문에, 디스크 접근 없이도 고속 조인이 가능하다. 메모리 부족 시에는 외부 해시 조인으로 전환되어 디스크 I/O가 발생하지만, 충분한 워킹 메모리가 보장되는 환경이라면 Hash Join이 훨씬 효율적이다.</p>
<p>&nbsp;</p>
<h3>Sort Merge</h3>
<p>Sort Merge Join은 결합 대상인 두 테이블을 각각 결합 키를 기준으로 정렬한 후, 정렬된 상태에서 순차적으로 스캔하면서 일치하는 결합 키를 찾아 결합하는 방식이다.&nbsp;</p>
<p><figure class="imageblock alignCenter"><span><img height="543" src="https://blog.kakaocdn.net/dn/dmZE3D/btsNJHF6kGJ/USdwOyJ1YwlwKhzWLWjlJk/img.png" width="586" /></span></figure>
</p>
<p>이때 두 테이블을 정렬하는 과정이 포함되므로, 결합 과정에서 두 테이블을 한 번의 스캔만으로 결합할 수 있다.</p>
<h4>Sort Merge의 특징</h4>
<p>Sort Merge Join은 결합 대상 레코드 수가 많더라도 조인 자체는 정렬된 데이터를 한 번씩만 읽기 때문에 비교적 안정적인 성능을 낼 수 있다. <span style="color: #333333; text-align: start;">그러나 이 방식은<span>&nbsp;</span></span>정렬 과정에서 많은 메모리와 리소스를 소모<span style="color: #333333; text-align: start;">하며,<span>&nbsp;</span></span>메모리가 부족해지면 TEMP 영역을 사용하는 디스크 I/O가 발생하여 성능 저하의 원인이 될 수 있다.</p>
<p>Sort Merge Join은 동치 조인뿐만 아니라 범위 조인에도 사용이 가능하다는 장점이 있지만, 부정 조건<span style="color: #666666;">(!=, NOT IN)</span>이 포함된 조인에는 일반적으로 사용되기 어렵다는 한계가 있다.<br />또한 원칙적으로 테이블이 이미 결합 키로 정렬되어 있다면 정렬 과정을 생략할 수 있지만, 이는 DBMS가 테이블의 물리적 저장 순서를 활용할 수 있을 때만 가능한, 즉 실제로 데이터가 디스크에 물리적으로 정렬되어 저장되어 있을 때만 가능한 구현 의존적인 최적화다.</p>
<p><span style="color: #333333; text-align: start;">따라서 Sort Merge Join은<span>&nbsp;</span></span><b>정렬된 인덱스가 존재하거나, 정렬 비용이 크지 않은 상황이라면 효과적인 조인 방식</b>이 될 수 있다. <span style="color: #333333; text-align: start;">하지만 그렇지 않은 경우라면,<span>&nbsp;</span></span><b>보다 일반적인 Nested Loops Join이나 Hash Join을 우선적으로 고려하는 것이 현실적인 선택</b>일 수 있다.</p>
<p>&nbsp;</p>