<h2>AI 에이전트란?</h2>
<p>'AI 에이전트'라는 용어는 다양한 맥락에서 폭넓게 사용되고 있지만, 그 정의가 명확하게 정립된 것은 아니다. OpenAI에서는 에이전트를 '사용자를 대신해 독립적으로 작업을 완수하는 시스템'으로 정의한다. 따라서 단순히 질문에 답변하는 챗봇이나 한 번의 LLM 호출로 끝나는 모델은 에이전트로 볼 수 없다. 정리하자면, <b>AI 에이전트는 복잡한 요구를 이해하고 스스로 계획을 세우며, 필요할 때 적절한 도구를 활용해 여러 단계를 거쳐 목표를 달성하는 능동적인 시스템</b>이다.</p>
<h3>증강된 LLM</h3>
<p>AI 에이전트는 단순한 대화형 모델이 아니라, 증강된 LLM(Augmented LLM)을 기반으로 동작한다. 증강된 LLM은 앤트로픽에서 제시한 개념으로 LLM이 스스로 목적을 달성하기 위해 외부 도구를 활용하고 필요한 컨텍스트를 확보하는 기법을 의미한다. 이는 RAG가 문서 검색을 통해 모델의 응답 품질을 높였던 것과 유사하지만, 더 넓은 ㄱ ㅐ념이다. 단순히 프롬프트에 정보를 추가하는 것을 넘어, 모델이 필요한 정보를 스스로 찾아내거나 도구를 호출해 가공한 데이터를 바탕으로 사고하고 응답하는 것이다.&nbsp;</p>
<p>이때, LLM이 사용할 수 있는 도구는 매우 다양하다. 예를 들어, 데이터 리소스나 API, 데이터베이스, 혹은 장기적인 대화 맥락을 기억하기 위한 메모리 등이 있다. 여기서 말하는 <b>'컨텍스트'</b>란 <b>이러한 도구를 통해 획득하거나 가공된 정보를 의미</b>한다. 즉, 증강된 LLM은 학습된 지식만으로 답하는 것이 아니라, 외부의 실시간 정보와 자원을 결합해 보다 정교한 판단과 실행을 수행한다.</p>
<h3>오케스트레이션 (Orchestration)이란?</h3>
<p>여러 도구와 시스템이 함께 동작하기 위해서는 이를 조율하는 매커니즘, 즉 오케스트레이션(Orchestration)이 필요하다,</p>
<p><figure class="imageblock widthContent"><span><img height="360" src="https://blog.kakaocdn.net/dn/bcz7Mf/btsQ3019vg3/KmVCZ5SIguguE8MQyZaDK0/img.png" width="716" /></span><figcaption>Agents by Google</figcaption>
</figure>
</p>
<p>구글의 Agent 백서에서는 오케스트레이션을 <b>'다양한 시스템과 서비스를 조율하고 실행하는 계층'</b>이라고 정의한다. 오케스트레이션 계층은 사용자의 요청을 적절히 분해하고 각 구성 요소가 수행해야 할 역할을 조정해 최종적인 결과를 만들어낸다. 오케스트레이션에는 개발자가 직접 설계하는 '프롬프트(Instruction)'이 포함된다. 시스템 프롬프트(System Prompt)라고 불리는 Instruction은 LLM이 어떤 방식으로 사고하고 행동해야 하는지를 지시하는 일종의 조정 명령이다. 다시 말해, 오케스트레이션은 다양한 에이전트 구성 요소가 유기적으로 협력하도록 이끄는 두뇌 역할을 담당한다.</p>
<h2>AI Agent 프레임워크의 등장</h2>
<p>이처럼 AI 에이전트는 단순한 모델 호출로 끝나는 시스템이 아니라, <b>복잡한 구성 요소들이 유기적으로 동작하는 구조</b>를 갖는다. 모델은 외부 도구를 사용해야 하고, 상태를 기억해야 하며, 여러 단계를 거쳐 목표를 수행해야 한다. 이러한 기능을 모두 직접 구현하는 것은 상당히 복잡하고 비용도 많이 든다. 이런 이유로 최근에는 <b>AI 에이전트 개발을 쉽게 해주는 프레임워크</b>들이 등장하고 있다. 대표적인 예로는 <b>OpenAI의 Agents SDK</b>와, LangChain을 기반으로 만들어진 <b>LangGraph</b>가 있다. 이들 프레임워크는 에이전트의 핵심 요소인 <b>도구 사용, 메모리 관리, 상태 전이, 오케스트레이션 로직</b> 등을 손쉽게 구성할 수 있도록 돕는다. 즉, 개발자는 저수준 구현보다는 <b>에이전트의 목적과 행동 전략 설계</b>에 집중할 수 있게 된다.</p>
<h3>OpenAI의 에이전트 SDK</h3>
<p>OpenAI의 에이전트 SDK는 올해 출시된 에이전트 프레임워크이다. AI 에이전트를 구축하고 조율하는데 필요한 최소한의 추상화를 제공한다.</p>
<h4>핵심 콘셉트</h4>
<p>오픈AI의 에이전트 SDK에는 4가지의 핵심 콘셉트가 있다. 바로 에이전트(Agents), 핸드오프(Handoffs), 가드레일(Guardrails), 트레이싱(Tracing)이다.</p>
<p>&nbsp;</p>
<ul>
<li><b>Agent</b><br />기본적으로 하나의 에이전트는 LLM을 기반으로 특정 역할을 수행하도록 설정된 인스턴스다. 즉, 이 에이전트는 지시문(instructions), 도구(tools), 가드레일, 핸드오프 등을 포함해서 구성되며, LLM이 단지 응답만 하는 것이 아니라 행동과 역할을 갖고 동작하도록 한다.<br /><br /></li>
<li><b>도구 (Tools)</b><br />도구는 에이전트가 외부 시스템과 상호작용하게 해 주는 매개체다. 예를 들어 코드 실행, 웹 브라우징, API 호출, 데이터베이스 쿼리, 기타 외부 함수 등이 될 수 있다. 이 도구들은 에이전트와 LLM 사이의 연결 고리 역할을 하며, 에이전트가 &lsquo;행동&rsquo;할 수 있게 해 준다.<br /><br /></li>
<li><a href="https://openai.github.io/openai-agents-python/" rel="noopener" target="_blank"><b>Handoffs</b></a><br />어떤 에이전트가 특정 요청을 더 잘 처리할 수 있는 경우, 제어를 다른 에이전트로 넘기는 메커니즘이다. Agents SDK에서는 핸드오프를 일종의 도구 호출(tool 호출)처럼 다루고, 에이전트가 스스로 &ldquo;이 작업은 내가 처리하지 않고, 이 에이전트에게 넘겨야겠다&rdquo;라고 판단할 경우 이 도구를 호출한다.&nbsp;<br /><br />핸드오프(Handoff)는 여러 에이전트를 함께 사용할 때 특히 유용하다. 과거에는 하나의 에이전트와 하나의 프롬프트로 다양한 작업을 처리하려는 시도가 많았지만, 최근에는 각 작업에 특화된 에이전트를 만들어 해당 작업을 처리하도록 하는 멀티 에이전트(Multi-Agent) 방식이 주목받고 있다. 핸드오프는 이러한 환경에서, 에이전트가 스스로 판단하여 특정 작업을 자신보다 더 적합한 다른 에이전트에게 넘길 수 있도록 하는 기능을 제공한다.<br /><br /></li>
<li><a href="https://openai.github.io/openai-agents-python/guardrails" rel="noopener" target="_blank"><b>Guardrails</b></a><br />에이전트의 입력(input)과 출력(output)에 대해 유효성 검사와 규칙 기반 필터링을 수행해 시스템의 안정성과 일관성을 보장하는 안전 장치다. 예컨대 필수 키워드 검사, 금칙어 필터링, JSON 스키마 기반 출력 검증, 사용자 정의 조건 검증 등이 가능하다. 입력 가드레일은 에이전트 실행 전에 먼저 검사하고, 출력 가드레일은 최종 응답이 생성된 뒤 검사하며, 검증 기준을 벗어나면 예외(tripwire)를 발생시켜 실행을 중단할 수 있다.&nbsp;<br /><br /></li>
<li><a href="https://openai.github.io/openai-agents-python/tracing" rel="noopener" target="_blank"><b>Tracing</b></a><br />에이전트의 실행 흐름을 기록하고 시각화할 수 있는 기능이다. Agents SDK는 LLM 호출, 도구 호출, 핸드오프, 가드레일 검사 등 주요 이벤트를 trace와 span 구조로 기록하며, 개발자가 디버깅하거나 워크플로우의 병목을 파악하는 데 활용할 수 있다. 기본적으로 tracing은 활성화되어 있으며, 필요하면 설정을 통해 비활성화할 수도 있다.&nbsp;<br />응답까지 걸린 시간이나 전후의 메세지들을 알 수 있기 때문에 모델의 응답 품질이 낮은 경우 시스템의 버그 혹은 부족한 데이터 등을 로그를 추적해가며 확인할 수 있다.</li>
</ul>
<h3>랭그래프 (LangGraph)</h3>
<p><b>랭그래프(LangGraph)</b>는 LangChain을 개발한 팀이 만든 <b>에이전트 오케스트레이션 프레임워크</b>로, 기존의 선형적인 체인 구조를 넘어 <b>복잡한 다중 에이전트 시스템과 상태를 가진 워크플로</b>를 설계할 수 있도록 만들어졌다. 이를 제대로 이해하기 위해서는 먼저 그래프 자료구조에 대한 기본 개념이 필요하다.</p>
<h4>그래프 자료구조</h4>
<p>그래프는 노드(Node)와 엣지(Edge)로 구성된 자료구조로, 객체 간의 관계를 표현하는 데 효과적이다. 그래프는 방향성을 기준으로 <b>방향 그래프</b>와 <b>무방향 그래프</b>로 나뉘는데, 랭그래프는 <b>방향 그래프</b>를 기반으로 한다. 이는 작업의 흐름이 특정 방향을 갖기 때문이다. 그래프의 또 다른 중요한 특성은 순환(Cycle)의 존재 여부다. 순환이 없는 그래프를 DAG(Directed Acyclic Graph)라고 하며, 많은 워크플로 시스템은 DAG만을 사용한다. 하지만 <b>랭그래프는 순환이 있는 그래프도 지원</b>한다. 이를 통해 특정 조건이 만족될 때까지 작업을 반복하거나 이전 단계로 돌아가는 등 복잡한 패턴을 구현할 수 있다.</p>
<h4>랭그래프의 핵심 개념</h4>
<p>랭그래프의 핵심 개념은 <b>상태(State), 노드(Node), 엣지(Edge)</b>로 요약할 수 있다.</p>
<ul>
<li><b>상태(State)<br /></b>그래프 실행 과정에서 지속적으로 유지되는 데이터로, 각 노드가 실행될 때 읽고 쓰기가 가능하다. 단순한 변수 전달을 넘어서, 전체 워크플로의 <b>컨텍스트를 관리하는 중앙 저장소</b> 역할을 한다.<br /><br /></li>
<li><b>노드(Node)<br /></b>그래프의 기본 실행 단위로, 특정 작업을 수행하는 함수나 에이전트를 나타낸다. 각 노드는 현재 상태를 입력으로 받아 LLM 호출, 데이터 처리, 외부 API 호출 등 작업을 수행하고, 업데이트된 상태를 반환한다. 노드는 순수함수일 수도 있고, 부수 효과(side effect)를 가질 수도 있다. 예를 들어 데이터베이스에 쓰기 작업을 하거나 외부 API를 호출할 수도 있다.<br /><br /></li>
<li><b>엣지(Edge)</b>&nbsp;<br />노드 간의 연결을 정의하고 실행 흐름을 제어한다. 랭그래프는 <b>일반 엣지</b>와 <b>조건부 엣지</b> 두 가지 유형을 지원한다. 일반 엣지는 항상 같은 경로로 진행되는 반면, 조건부 엣지는 상태에 따라 다른 노드로 분기할 수 있어 <b>동적 라우팅</b>을 가능하게 한다. 이를 활용하면 AI 에이전트가 상황에 따라 다른 전략을 선택하거나, 오류 처리 로직을 구현하는 데 매우 유용하다.</li>
</ul>
<hr contenteditable="false" />
<p>결과적으로 랭그래프는 <b>다중 에이전트, 상태 관리, 동적 분기</b>를 자연스럽게 지원하면서, 복잡한 워크플로를 직관적이고 유연하게 설계할 수 있는 강력한 오케스트레이션 프레임워크다.</p>